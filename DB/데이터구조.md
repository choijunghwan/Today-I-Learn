# 오라클 데이터 구조의 필요성?

오라클은 전달받은 데이터를 그대로 저장하는 것이 아니라, 몇 개의 상자로 나누어서 저장하도록 고안됐습니다. 그래서 상자와 관련된 이야기(데이터 구조)는 평상시 업무에서도 빈번하게 화두에 오르며, 애플리케이션 개발 팀에서도 테이블이나 인덱스의 생성과 생성 요청을 해야하므로 어느 정도의 지식이 필요합니다. 그리고 성능과 관련된 부분에서도 데이터 구조와 관련된 지식은 필요합니다.

먼저 데이터구조에 관한 용어 입니다.

- 테이블 스페이스(tablespace)
- 세그먼트(segment)
- 익스텐트(extent)
- 블록(block)
- 데이터 파일(datafile)

예를 들어, '테이블 스페이스가 가득차면 데이터 파일을 추가하자' 나 'ORA-30036 unable to extend segment by 8 in undo tablespace'같은 에러의 대응에서도 이런 용어들을 많이 사용하므로 데이터 구조는 이해해 두는것이 좋습니다.

데이터 구조의 필요성은 이해를 했는데 왜 이렇게 복잡한 구조로 되어있을까? 라는 의문을 가지는 분들이 있습니다.

만약 한 테이블에 저장된 데이터가 100만 건이라고 가정하고, 데이터를 차례대로 저장할 경우어떤 문제가 발생하는지 살펴보겠습니다. 데이터베이스를 관리하기 위해서는 어떤 테이블이 어떤 데이터를 가졌는지에 대한 정보가 필요합니다. 만약 기존처럼 차례대로 저장하는 방식이라면 데이터가 100만건 있을때 100만개의 관리 정보가 필요합니다. 또한 100만 건의 데이터를 읽어오는 데 100만 번의 I/O가 필요해질지도모릅니다.

반면에 100만 건을 1만 건을 한 개의 집합으로 관리한다면 100개의 관리 정보만 있으면 됩니다. 또한 I/O 홧수도 100회로 충분합니다. 

따라서 관리 및 I/O 효율을 고려해 공간을 어느 정도의 크기로 뭉쳐서 할당하기 위해 위와 같은 데이터 구조가 필요합니다.

<br><br>

# 데이터 구조

오라클의 데이터 구조는 크게 물리 구조, 논리 구조로 나눌 수 있습니다. 일반적으로 사용하는 물리 구조/논리 구조에 맞추어 설명한다면 물리 구조는 데이터 파일 등의 OS에서 보이는 구조를 의미하고 논리구조는 OS에서는 식별할 수 없는 오라클 내부의 구조를 의미합니다.

예를 들어, 데이터 파일 안에 보관된 '테이블'이나 '로우(행)'는 논리 구조입니다.

오라클 전처의 데이터 구조는 아래와 같습니다.

<그림 7.5>

위의 그림을 토대로 작은 구조부터 차례대로 살펴보겠습니다. 가장 작은 구조(집합)는 **(오라클)블록**입니다. 블록은 8KB 같은 크기로 나뉜 공간을 말합니다. 이 블록 안에 한 건 이상의 데이터가 보관됩니다. 

<그림 7.6>

데이터가 입력(INSERT)되면, 이공간의 아래에서부터 차례대로 사용해나갑니다. 단 어느 정도 사용하면 데이터를 추가로 입력하지 않고, 앞으로 발생할 데이터의 변경을 대비해 빈 공간을 확보해둡니다.

**익스텐트**는 연속된 블록의 집합입니다. 익스텐트 덕분에 각 블록의 위치가 아니라 각 인스텐트의 첫 위치와 블록의 개수만으로 데이터를 관리할 수 있으며, 관리 정보도 줄일 수 있게 되었습니다.

<그림 7.7>

또한, 데이터를 한 번에 읽어올 수 있으므로 테이블의 풀 스캔 성능을 향상할 수도 있습니다.

테이블이나 인덱스 등의 데이터를 한번 더 모은 익스텐트의 집합을 **세그먼트**라고 부릅니다.

테이블과 세그먼트, 익스텐트 관계를 정리한 것이 아래그림입니다.

<그림 7.8>

<br><br>

# 실제 흐름을 통한 각 동작 확인

1. 데이터베이스 생성
    1. 우선 데이터베이스의 생성입니다. 이때 SYSTEM 테이블스페이스를 시작으로 몇 가지 테이블 스페이스가 생성되ㅣㅂ니다.
2. 사용자용 테이블 스페이스의 생성
    1. 사용자용 테이블 스페이스를 생성합니다.
    2. 사용자용 테이블 스페이스를 생성하는 것은 데이터베이스를 생성할 때 같이 해도 상관없습니다.
3. 테이블을 테이블스페이스에 생성
    1. 테이블스페이스에 테이블을 생성합니다.
    2. 이 시점에서 내부가 비어 있는 상태로 익스텐트가 생성됩니다.
    3. 익스텐트가 생성된 후에 데이터 입력(INSERT)이 수행되며, 익스텐트의 비어 있는 블록에 데이터를 입력합니다.
    4. 'PCTFREE'라는 임계치에 도달하면 해당 블록에 입력하는 것을 멈추고 다음으로 비어 있는 블록에 데이터를 입력합니다.
    5. 데이터의 입력이  계속되어 익스텐트가 가득 차게 되면 테이블스페이스가 가지고 있는 빈 공간을 사용해 새로운 익스텐트를 테이블에 할당하고 데이터를 입력하게 합니다.

<br><br>

# 프로세스에서 본 데이터 구조

오라클의 메모리 내부의 동작에 대해 검색(SELECT)와 변경(UPDATE)을 한번 살펴보겠습니다.

여기서는 검색은 풀 스캔이라고 가정하겠습니다.

<br>

### 데이터 검색

 <그림 7.10>

오라클은 해당 테이블의 익스텐트를 조사하고 버퍼 캐시에 존재하지 않는 블록을 처음부터 읽어옵니다.

<br>

### 데이터 변경

데이터 변경은 인덱스를 사용해 한 건만을 변경한다고 가정하겠습니다.

<그림 7.11>

1. 우선 인덱스에 접근하고 인덱스의 관리 정보를 토대로 인덱스의 루트 블록(가장 위의 블록)을 찾아갑니다.
2. 이어서 루트 블록에서 다음 블록의 주소를 조사하고, 그 블록이 캐시에 적재되어 있지 않다면 디스크에서 읽어옵니다.
3. 이렇게 반복해서 필요한 해당 데이터 블록을 찾습니다.
4. 대상 테이블 데이터의 블록이 캐시에 적재되어 있지 않다면 해당 블록만을 읽어옵니다.
5. 그리고 캐시상에서 블록의 데이터를 변경합니다.