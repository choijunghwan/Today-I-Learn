# I/O의 지연이 발생하면 오라클은 어떻게 되는가?

### I/O 지연 발생했을때의 상황과 조사 방법

오라클 시스템에서 I/O가 지연되었다면 오라클의 처리도 지연됩니다. 비유해보자면 은행 창구의 처리(I/O처리)가 느려진 상태입니다.  고객의 수가 평소와 같다 해도 일 처리를 느릿느릿하게 한다면, 고객이 줄을 서서 기다리는 상황을 상상할 수 있을 것입니다.

OLTP 시스템에서는 오라클에도 대기열(큐)이 발생하고, 쉬고(idle) 있지 않은 세션수의 형태로 나타납니다.

조사하는 방법으로는 오라클의 AWR, 스태츠팩이나 OS의 I/O 정보에 표시되는 I/O 1회의 시간, v$session_wait에서 확인할 수 있는 I/O 관련 대기 이벤트의 수, 유닉스는 vmstat에서의 b 컬럼(디스크 I/O를 대기하는 프로세스 수)을 조사하며 됩니다.

단, DBWR이나 LGWR의 I/O 지연은 I/O에 대기열이 생기지 않습니다. 서버 프로세스가 DBWR이나 LGWR의 I/O처리를 기다리는 것이므로 서퍼 프로세스의 대기 이벤트(ex: log file sync)가 대량으로 발생하는 것을 통해 확인 할 수 있습니다.

<br>

### 배치 시스템에서 I/O의 지연 조사 방법

배치 시스템은 OLTP와 동작이 다릅니다. 그 이유는 동시에 발생하는 작업 요청의 수가 한정되어 있기 때문입니다. 예를 들면, 한 번에 대량 처리를 의뢰하는 소수의 고객만을 전담하여 운영하는 은행이라고 생각하시면 됩니다. 하지만 창구의 업무 처리가 늦어지면 고객의 요청한 처리가 끝나는 시간도 늦어질 수밖에 없습니다. 이러한 지연을 조사하는 방법으로는 오라클의 AWR, 스태츠팩이나 OS의 I/O 정보에 표시되는 1회의 I/O 걸린 시간을 조사하면 됩니다.

<br>

### I/O 관련 대기 이벤트에는 어떤 것이 있는가?

- db file sequential read : 싱글 블록 I/O
- db file scattered read : 멀티 블록 I/O
- read by other session : 다른 세션이 읽어오는 중이므로 대기
- write complete waits : 기록하고 있으므로 대기
- buffer busy waits : 블록 사용 중
- free buffer waits : 빈 버퍼가 부족하다
- log file sync : REDO 로그 기록을 대기

<br><br>

# 네트워크에서 지연이 발생하면 오라클은 어떻게 되는가?

네트워크 지연이 발생하면 서버 프로세스에게 작업 요청이 도착하지 않은 상태이므로 서버 프로세스가 요청을 기다리는 'SQL*Net message from client' 상태를 유지하고 있습니다.

오라클의 관점에서는 네트워크에 지연이 발생해서 작업이 요청이 도착하지 않았을 때는 처리할 작업이 없는 것처럼 보입니다.

이를 조사하기 위해서는 **애플리케이션 측면에서 봤을 때는 요청을 보냈지만, v$session을 사용해서 데이터베이스를 확인해보니 작업 요청이 아직 도착하지 않았다는 상황을 직접 확인**하거나, **패킷 캡처 도구를 이용해서 패킷의 송수신을 직접 보는 방법**이 있습니다.

주의할 점은 패킷 캡처 도구를 사용할 때는 OS나 네트워크에 부담이 갈 수 있으므로 부담이 가지 않도록 주의해야 합니다.

<br><br>

# OS에서 지연이 발생하며 오라클은 어떻게 되는가?

OS의 어디가에서 지연이 발생하면 전체적으로 처리하는 속도가 느려집니다. OLTP 시스템에서는 대기열이 발생하지만 어디에 대기열이 생길지는 알 수 없습니다. 주로 '**latch free**'라는 오라클 내부의 Lock을 가진 대기 이벤트의 형태로 나타나는 일이 많습니다.

이런 상황을 조사하기 위해서는 OS 측의 정보를 사용해 조사하는 것이 좋습니다. 유닉스라면 `vmstat`, `sar` 등을 통해 CPU의 사용률을 조사하거나 윈도우라면 `성능 모니터`를 사용할 수 있습니다.

<br><br>

# 테스트할 때 오라클에 과도한 부하를 주면 어떻게 되는가?

과부하 상태가 되면 주로 오라클 내부에서 대기열이 생기며, 애플리케이션의 응답 시간이 악화됩니다.

이런 상황을 조사하기 위해서는 **OS의 정보, I/O의 정보, v$session_wait** 등에서 대기열이 생기지 않았는지를 확인하는 방법이 있습니다. 또는 커넥션 수를 줄이는 방법 등으로 가능한 한 부하를 줄인 후 처리에 걸리는 시간의 변화를 조사하는 방법도 있습니다. 만약 이렇게 조치해서 처리 시간이 짧아졌다면, 과부하가 원인이었을 가능성이 크다고 말할 수 있습니다.

<br><br>

# 대기 이벤트가 많으며 CPU의 사용률이 높은 상황이 발생한 이유는?

OLTP 시스템에서는 운영 환경과 개발 환경을 가리지 않고 대기 이벤트가 많아지고, CPU 사용률이 높아지는 현상이 발생하는 경우가 있습니다. 이럴 때 자주 받는 질문이 '대기 이벤트가 많으니까 CPU도 많이 소비되는 것이 아닌가?' 라는 질문입니다.

기본적으로 대기 이벤트를 OS에서 확인해보면 슬립한 상태입니다. 그 말은, 대기 이벤트로 인해 CPU 사용률이 상승하는 경우는 거의 없다는 것을 의미합니다. 반대로 CPU가 부족한 상황이 된다면 부자연스러운 대기가 발생하므로 대기 이벤트를 대기하는 기간이 길어집니다. 

먼저 어째서 CPU를 많이 소비하는가를 생각해 볼 필요가 있습니다. CPU의 부족이 원인이라면 처리 시간이 길어질 수 밖에 없습니다. 그러면 우선 CPU 부하를 줄일는 방안을 검토해야 합니다.

그러나 위의 경우가 아니라면 Lock을 기다리는 시간이 많기 때문입니다. Lock을 기다리는 시간을 줄이기 위해서는 Lock을 걸고 있는 처리를 얼마나 빠르게 끝낼 수 있는가, Lock을 획득하러 가는 횟수를 어떻게 줄일 수 있는가를 검토해봐야 합니다.

<br><br>

# 성능에 문제가 발생했을 때 데이터베이스의 상태(개요)를 확인하려면?

데이터베이스의 상태를 알기 위해서는 '오라클의 EM(Enterprise Manager)'이나 시판 중인 솔루션을 사용하는 방법도 있지만 여기서는 데이터베이스의 상태를 알아보는 데 필요한 구조를 살펴보겠습니다.

OLTP 시스템에서 발생하는 성능 장애를 토대로 설명해보면, 장애가 발생했을 때 우선 작업의 처리가 진행 중인지(처리량, throughput)를 조사합니다. 또한 대기가 없는지(응답시간)도 확인해야 합니다.

> v$sysstat에 'execute count'라는 SQL의 실행 수(오라클 기동 후의 누적치)가 있으므로 이것을 정기적으로 조사하면 처리량을 알 수 있습니다.
> 

또한 v$session_wait를 이용해서 대기가 많은지 여부를 알 수 있습니다.

<br>

**주요관점**

- 처리량이 적으며 대기가 많은 상황이라면 해당 대기가 지연의 원인일 가능성이 높다.
- 처리량이 적으며 대기가 거의 없는 상황이라면 오라클까지 요청이 도착하지 않았을 가능성이 높다.(애플리케이션이나 네트워크의 지연이 원인일 수 있다)
- 처리량에 비례해서 대기가 많은 상황이라면 단순히 처리량이 많은 상황일 수 있다.

<br><br>

# 성능 문제를 모니터링하거나 정보 수집을 효과적으로 하기 위해서는??

성능 장애를 모니터링하기 위해서는 애플리케이션 측에서 데이터베이스의 응답 시간을 계측해야 합니다. 이렇게 계측했을 때 일정 시간이 지나도 응답이 돌아오지 않는다면 지연이 발생했다고 판단할 수 있습니다. 지연시킬 가능성이 있는 대상을 외부에서 모니터링 하는 방법이 가장 확실하다 할 수 있습니다.

OLTP 시스템에서 살펴본다면 오라클에 지연이 발생했을 때 나타나는 대기 이벤트의 양을 보는 방법이 있습니다. `v$session_wait`, `v$session` 등에서 대기 중인 세션의 양을 정기적으로 학인하고 임계치를 넘었을 때 통보할 수 있는 체계를 미리 만들어 두면 좋습니다.

정보를 상시 수집하는 도구로서 SQL 트레이스를 수집하는 것도 좋지만 자원을 사용하므로 추천하지는 않습니다.

주로 사용하는 것은 `v$session`, `v$session_wait`, `v$sysstat` 입니다.

`v$session`이나 `v$session_wait`는 '그 당시의 상태'를 알 수 있으며, `v$sysstat`은 처리량 등의 상세한 내용을 알 수 있습니다.