# 트랜잭션 특성 ACID

**A(Atomicity) 원자성**

- DBMS는 수행 중인 트랜잭션에서 데이터를 일부만 변경하고 나머지는 수행하지 않은 채 커밋할 수없습니다.

**C(Consistency) 일관성**

- 트랜잭션에 의해 데이터 간의 일관성이 어긋나서는 안된다.

**I(Isolation) 고립성**

- 트랜잭션끼리는 고립되고 독립되어 있다

**D(Durability) 지속성**

- 커밋한 트랜잭션은 장애가 발생하더라도 데이터는 반드시 복구되어야 한다

데이터베이스의 중요한 특징인 커밋한 데이터를 지키는 특성을 구현하기 위해서는 로그(변경 로그)를 채용하여 성능과 지속성을 양립시킵니다. REDO로그에 데이터를 한꺼번에 기록하는 것으로 I/O의 횟수가 줄어들고, 시퀀셜 액세스를 사용하여 I/O에 소모되는 시간을 줄였기 때문입니다. 또한 I/O 크기는 커지지만, 첫머리를 찾아가는 작업의 횟수는 변하지 않으므로 I/O 시간이 지연되지 않습니다.

# Redo와 Undo

REDO로그란 **데이터의 변경 기록을 기록**한 것이고, UNDO로그는 **어떻게 하면 과거의 상태로 돌아갈 수 있는지에 관한 정보**입니다.

그러나 이러한 개념만으로는 이해가 쉽지 않기 때문에 한가지 예를 들어 생각해보겠습니다.

A군이 현재 집에 있는 상태라고 가정을 해보겠습니다.

그리고나서 A군 학교로 이동을 하였습니다.

그러면 A군은 집 → 학교로 상태가 변경 되었기 때문에 REDO 로그는 **A군이 학교에 갔다**는 변경 기록을 저장하게 됩니다. 그런데 만약 A군이 학교로 이동하기 전의 상태로 되돌리려고 하면 REDO 로그만으로는 학교에 오기 전에 어디에 있었는지 알 수 가 없습니다. 그래서 UNDO 로그를 통해 **A군를 집으로 돌려놓는다**라는 정보를 저장해줍니다.

이렇게 REDO로그를 통해 과거의 데이터를 최신데이터 쪽으로 흐르게 하는 것을 롤 포워드(roll-forward)라고 하고, UNDO 로그를 통해 과거의 상태로 되돌리는 것을 롤백(rollback)이라고 합니다.

### REDO의 구조

그렇다면 REDO 로그의 구조는 어떻게 되어 있을까요??

<그림 9.7>

REDO 로그용 메모리로서 REDO 로그 버퍼가 공유 메모리에 존재합니다. REDO 로그를 디스크에 REDO 로그 파일로 기록하는 것은 LGWR이라고 불리는 프로세스가 수행합니다.

또한 REDO 로그 파일은 개수가 한정(일반적으로 한 세트에 3개)되어 있으며, 크기도 제한되어 있으므로 REDO 로그를 계속 보관하고 있을 수는 없습니다.

그래서 아카이브 REDO 로그파일이라는 오랫동안 REDO 로그를 보관해두기 위한 파일이 존재합니다. REDO 로그 파일은 REDO 로그의 일시적인 보관 창고이며, 아카이브 REDO 로그 파일이 오랜 시간 보관할 수 있는 본격적인 보관 창고입니다.

REDO 로그 파일은 매우 중요한 파일이므로 반드시 다중화해야 합니다. 일반적으로 REDO 로그 그룹을 여러 개의 세트로 만들고, 그룹 안에 멤버(REDO 로그 파일)를 추가합니다. 여기서 다중화는 그룹을 늘리는 것이 아닌 멤버를 늘리기 때문에 주의해야합니다.

**REDO 효과**

REDO 로그를 통해 데이터베이스는 많은 장점을 얻을 수 있습니다.

- 병렬 처리를 가능케 하고 높은 처리량을 실현
    - 기본적으로 여러 개의 서버 프로세스는 데이터를 동시에 변경할 수 있습니다. (단, 같은 데이터는 제외)
    - REDO 로그를 기록하는 데에서도 LGWR은 여러 서버 프로세스의 REDO 로그를 한꺼번에 기록하기 때문에 높은 처리량을 구현할 수 있습니다.
- 응답 시간(response time)을 중시
    - 커밋할 때 블록을 디스크에 기록하지 않고 REDO 로그에 기록하는 것으로 빠른 커밋을 구현할 수 있습니다.
    - 1차로 REDO 로그에 기록을 한뒤 추후에 디스크에 기록을 합니다.
- 커밋한 데이터는 지킴
    - 장비에 장애가 발생하여 DBWR이 데이터를 기록할 틈도 없다고 가정하더라도 그 후에 REDO 로그와 데이터 파일에 남아있는 오래된 데이터를 사용해서 데이터를 복구할 수 있습니다.

### UNDO 구조

<그림 9.9>

데이터가 변경되면 UNDO 정보가 생성되며, 생성된 UNDO 정보는 세그먼트에 보관됩니다.

세그먼트에 보관된다는 점으로 인해 UNDO 정보가 테이블스페이스들 중 어딘가에 보관된다는 사실을 알 수 있습니다. UNDO 정보가 보관되는 테이블스페이스를 UNDO 테이블스페이스라고 부릅니다. UNDO 테이블스페이스에는 여러 개의 UNDO 세그먼트가 생성됩니다. 기본적으로 트랜잭션과 UNDO 세그먼트가 일대일로 대응하기 때문입니다.

UNDO 세그먼트는 링 버퍼(ring buffer)입니다. 링 버퍼는 조금 지나면 데이터가 덮어쓰이는 버퍼이지만, 커밋하지 않는 데이터는 덮어써지지 않습니다. 덮어쓰지 못하고 UNDO 세그먼트가 가득 차면 UNDO 세그먼트가 커집니다.

### UNDO 사용

- UNDO는 읽기 일관성을 지원해줍니다.

읽기 일관성이란, 데이터를 검색할 때 어떤 시점의 데이터를 보여주는 기능을 말합니다.

예를 들어, 검색을 시작한 후에는 다른 세션에서 변경한 데이터를(커밋을 했더라도) 읽지 못하게 하고, 검색 중에는 계속해서 검색을 시작한 시점의 데이터를 보여주는 것을 말합니다.

읽기 일관성은 데이터가 변경된 시점을 확인하고, 검색을 시작한 후에 변경된 데이터일 떄는 UNDO를 사용해서 과거의 데이터를 메모리 위에 재현합니다.