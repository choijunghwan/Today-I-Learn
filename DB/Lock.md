# Lock이란?

먼저 오라클에 왜 Lock이 필요한지 예를 한번 들어보겠습니다.

만약 고객이 창고에 ID=1인 물건의 내용에 숫자 1을 더하고 싶다고 요청했습니다.

```sql
SELECT counter FROM counter_table WHERE id = 1;
UPDATE counter_table SET counter = <새로운 값> WHERE id = 1;
```

하나의 요청만을 보니 아무런 문제가 없을것 같아보입니다.

하지만 오라클은 병렬처리가 가능하다는 특징이 있습니다.

만약 A라는 고객이 ID=1 인 물건에 숫자 1을 더하고 싶다고 요청을 해서 SQL을 처리하고 있는 중에 B라는 고객이 ID=1인 물건에 숫자 1을 더하고 싶다고 요청을 했다고 생각해봅시다.

물건의 값이 1이라고 가정해보겠습니다.

원래라면 A,B 고객에 의해 1씩 더해져 물건의 값은 3이 되어야 합니다. 하지만 A라는 고객의 SQL을 처리하는 중에 B가 데이터에 접근한다면 B 고객이 보는 데이터는 아직 1이 증가하지 않은 1이라는 값을 가리키고 있기 때문에 A,B의 모든 요청을 처리한 후의 데이터는 2가 되어버립니다.

이러한 일이 일어나는 원인은 데이터를 변경할때 데이터가 보호받지 못했기 때문입니다.

고객 A가 데이터를 변경하는 동안에는 고객 A이외에는 해당 데이터를 변경할 수 없도록 변경하는 데이터에 Lock을 걸어서 보호해야만 합니다.

즉 Lock이란 '**다중 처리를 구현하기 위해 데이터를 보호하는**'것 입니다.

```sql
SELECT counter FROM counter_table WHERE id = 1
FOR UPDATE;  <- Lock이 걸린다
UPDATE counter_table SET counter = <새로운 값> WHERE id = 1;
```

SQL에서는 SELECT 단계에서 Lock을 거는 것도 가능합니다.  첫 SELECT에 의해 id가 1인 로우에 Lock이 걸립니다. 로우 Lock이 걸렸기 때문에 동일한 로우를 대상으로는 SQL 작업을 수행할 수 없어 기다려야 합니다.

```java
UPDATE counter_table SET counter = counter+1 WHERE id = 1;
```

위 SQL은 SELECT 단계에서 Lock을 거는 과정이 없이 바로 데이터 변경이 일어납니다. 이러한 경우는 어떻게 될까요??  사실은 UPDATE문 등의 DML(Data Manipulation Language)은 자동으로 로우 Lock을 걸기 때문에 문제가 발생하지 않습니다.

다만 UPDATE문을 대량으로 수행하면 Lock대기가 발생합니다. Lock 대기는 데이터를 보호하기 위해 발생할 수 밖에 없기때문에, 대량의 DML을 실행해야 할 때는 이런 부분을 감안하고 작업을 개선할 수 밖에 없습니다.

<br><br>

# 대기와 Lock 대기
### 대기

대기에는 크게 **Idle 대기**, **Non-Idle 대기** 두가지가 있습니다.

 

Idle 대기는 '처리할 것이 없어서 쉬고 있는 대기'를 말합니다. Idle 대기 이벤트는 SQL의 처리를 기다리게 하지 않으므로 성능을 분석할 때는 신경을 쓰지 않아도 됩니다.

Non-Idle는 '이유가 있어 어쩔 수 없이 하는 대기', '이상 상태 등 쓸데없이 SQL을 기다리게 하는 대기'가 있습니다.

이유가 있어 어쩔 수 없이 하는 대기는 예로 디스크 I/O 대기가 있습니다. 이것은 SQL 처리에 필요한 대기라고 할 수 있습니다.

이상 상태 등 쓸데없이 SQL을 기다리게 하는 대기는 판단하기 어렵습니다.

예를들어 이상 상태라는 것은 '한 사용자가 어떤 테이블에 Lock을 걸어 버린 후에 식사하러 갔다'등의경우를 말합니다. 이렇게 되면 다른 사용자가 해당 테이블의 데이터를 변경할 수 없으므로 Lock을 통해 데이터는 보호되지만 쓸데없는 대기라 할 수 있습니다.

SQL의 처리 과정을 튜닝한다는 관점으로 바라보면 'Non-Idle 대기 이벤트 + SQL 처리에 사용하는 CPU 시간'이 SQL에 걸린 시간이므로 매우 중요한 부분입니다.

<br>

### Lock 대기

다음으로 Lock으로 인해 발생하는 대기에 알아보겠습니다.

Lock을 걸었다는 것 자체만으로는 대기가 발생하지는 않으며, Lock이 걸려 있는 대상에 다시 Lock을 걸려고 했을 때 대기가 발생합니다.

자주 볼 수 있는 Lock은 'TX'와 'TM'입니다. TX는 로우와 관련된 Lock이며, TM은 테이블에 거는 Lock입니다. 오라클은 'MODE'를 통해 Lock이 어떤 형태로 걸려 있는지를 표시해줍니다.

예를 들어, TX Lock은 로우에 대하여 다른 MODE의 Lock을 허용하지 않습니다. 이와 비교해서 DML을 할 때 자주 발생하는 RX MODE로 TM Lock을 얻을 수 있습니다. RX MODE의 TM Lock이 걸려 있다면 테이블의 정의를 변경하는 등의 작업은 할 수 없지만, 테이블에 대해 여러 개의 트랜잭션을 수행할수는 있습니다. 이런 식으로 MODE를 잘 활용하면 필요한 상호 배제를 구현하면서 동시성을 함께 실현할 수 있습니다.

<br>

### DeadLock
DeadLock이란 서로가 상대방이 보유하고 있는 Lock을 기다리느라 영원히 작업 처리를 진행할 수 없는 상태를 말합니다.

DeadLock일 때는 한쪽의 처리가 오라클에 의해 자동으로 롤백되며, alert 파일과 트레이스 파일에 정보가 표시됩니다. 오라클의 버전이 9i 이후 버전이라면 Deadlock이 발생한 SQL 문을 양쪽 모두 알 수 있어서 애플리케이션을 수정할 때 도움이 됩니다.