프로젝트를 개발하다보면 트래픽이 증가함에 따라 Scale Up, Scale Out을 고민하게 됩니다.

Scale Up(스케일 업)은 서버의 성능을 증가시키는 방법이고, Scale Out(스케일 아웃)은 새로운 서버를 추가하여 성능을 증가시키는 방법입니다.

Scale Out을 하면 서버의 추가 증가하므로서 단일 서버와 다르게 다중 서버 환경에서의 고려해야 하는 부분들이 증가하게 됩니다.

그중에서 Session에 관해서 한번 공부해보겠습니다.

<br><br>

# 다중 서버 환경

먼저 Scale Out이 되면서 다중 서버 환경이 되면 Session이 어떻게 구성되는지 한번 살펴보겠습니다.

![image1](/Img/Session/Session1.png)

위의 그림과 같이 서버 하나당 하나의 세션 저장소가 형성됩니다. 세션 저장소에 대한 별도의 처리가 없다면 각 Session 저장소의 데이터 불일치 현상이 발생하게 됩니다.

<br>

### Sticky Session

Sticky Session 이란 고정된 세션을 의미합니다. 

세션 저장소가 분리되어 데이터 불일치 현상이 발생하는것을 방지하기 위해 기존에 접속한 세션에만 접근할 수 있게 하는 방식입니다.

<br>

![image2](/Img/Session/Session2.png)

예를들어, User1 이 1번~3번까지의 서버 중 1번 서버에 세션을 생성하였다면, 이후에 User1이 보내는 모든 요청은 1번 서버로만 보내지게 됩니다. Load Balancer는 User가 첫 번째 세션을 생성한 서버로 모든 요청을 리다이렉트 하여 고정된 세션만 사용하게 합니다.

이를 위해서 Load Balancer(로드 밸런서)는 요청을 받으면 가장 먼저 요청에 쿠키가 존재하는지 확인합니다. 쿠키가 있으면 해당 요청이 쿠키에 지정된 서버로 전송됩니다. 쿠키가 없는 경우에는 로드 밸런서가 기존 로드 밸런싱 알고리즘을 기반으로 서버를 선정합니다.

이러한 방식을 사용하면 유저는 세션이 유지되는 동안 동일한 서버만 사용하기 때문에 정합성 이슈에서 자유로워 질 수 있습니다.

그러나 고정된 세션을 사용하게 된다면 트래픽이 증가할 경우 자동으로 여러 서버에 트래픽을 분산시켜주는 로드 밸런서의 장점을 활용할 수 없게됩니다. 그리고 서버가 정해지기 때문에 하나의 서버에 트래픽이 집중되는 경우를 해결할 수 없습니다.

게다가 하나의 서버에 장애가발생하게 되면 해당 서버를 사용하는 사용자들의 세션 정보를 잃어버리게 되는 문제가 발생합니다.

<br>

### 세션 클러스터링

위의 고정된 세션 방법으로는 정합성 이슈를 어느정도 해결할 수 있었지만, 완벽하지 않고, 트래픽 분산등 확장성에서는 단점이 존재했습니다.

이러한 단점을 해결하기 위한 세션 클러스터링 방식에 대해 알아보겠습니다.

여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것을 **클러스터링**이라고 합니다. 서버 또한 컴퓨터로써 여러 대가 하나의 서비스를 하기 위해서는 클러스터링이 필요합니다.

<br>

**Tomcat all-to-all 방식**

Tomcat의 all-to-all 세션 복제 방식이 있습니다.

all-to-all 세션 복제란 하나의 세션 저장소에 변경되는 요소가 발생하면 변경된 사항이 다른 모든 세션에 복제가 된다는 것을 말합니다.

<br>

![image3](/Img/Session/Session3.png)

위와 같이 세션을 복제한다면 유저가 이후에 어떤 서버에 접속하더라도 로그인 정보가 세션에 복제되어 있으므로 정합성 이슈가 해결 가능합니다. 또한 확장에도 용이합니다.

그러나 **all-to-all 방식**은 모든 서버가 동일한 세션 객체를 가져야 하기 때문에 많은 메모리가 필요하여 메모리 낭비가 발생하며, 세션 저장소에 데이터가 저장될 때마다 모든 서버에 값을 입력해줘야 하므로 서버 수에 비례하여 네트워크 트래픽이 증가하는 등 성능 저하가 발생하게 됩니다.

그러므로 **all-to-all 방식**은 소규모 클러스터에서는 고려해볼만한 방식이지만 4개 이상의 어느정도 규모가 있는 클러스터에서는 추천하지 않는 방식입니다.

만약 **all-to-all방식**을 4개 이상의 대규모 클러스트에서 적용할려면 **primary-secondary 세션 복제 방식**을 활용할 수 있습니다.

all-to-all 방식은 key-value 전체를 복제한다면 primary-secondary 방식은 Secondary 서버에는 key-value 전체를 복제하지만, 이외의 서버에는 key값만 복제하여 메모리 사용을 줄이는 방식입니다.

primary-secondary 방식을 사용해도 성능적인 한계가 존재합니다.

그러면 성능적인 부분도 보완할 수 있는 방법은 없을까요??

<br>

### 세션 스토리지 방식

기존의 데이터 정합성, 성능 문제를 모두 해결할 수 있는 방식이 세션 스토리지 방식입니다.

이는 기존 서버가 갖고 있는 로컬 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소를 사용하는 것을 의미합니다.

<br>

![image4](/Img/Session/Session4.png)

위와 같이 세션 스토리지가 분리되면, 서버가 아무리 늘어난다고 해도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있게 됩니다.

또한 세션 스토리지와 로드밸런싱을 같이 사용하게 되면 Sticky Session처럼 트래픽이 비정상적으로 몰리는 현상도 발생하지않게 되고, 서버 하나가 장애가 발생하더라도 별도의 세션 저장소가 존재하기 때문에 서비스를 계속해서 제공할 수 있습니다.

그리고 세션 클러스터링을 통해 해결하였던 데이터 정합성 문제도 여러대의 서버가 하나의 세션을 사용하기 때문에 해결가능하며 하나의 세션을 사용하기 때문에 세션 복제를 할 필요가 없어 성능적인 문제도 해결이 가능합니다.

그치만 세션 저장소에 에러가 발생하게 되다면 모든 서버에서 세션 이용이 불가능하기 때문에 이런 경우를 예방하기 위해 세션 저장소도 복제해 안정성을 확보하기도 합니다.